package ghitbug.zqdszb.library.utils.utils.DES3;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.spec.KeySpec;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESedeKeySpec;/** * 该方法根据android做过调整 *  * @author Rocky.H *  */public class StringEncrypt{	public static final String DESede = "DESede";	private KeySpec keySpec;	private SecretKeyFactory keyFactory;	private Cipher cipher;	public StringEncrypt(String encryptKey) throws Exception	{		try		{			byte[] keyAsBytes = encryptKey.getBytes("UTF8");			keySpec = new DESedeKeySpec(keyAsBytes);			keyFactory = SecretKeyFactory.getInstance(DESede);			cipher = Cipher.getInstance("DESede/ECB/PKCS7Padding");// DESede/ECB/PKCS5Padding		}		catch (Exception e)		{			e.printStackTrace();			throw new Exception(e);		}	}	public String encrypt(String unencryptedString) throws Exception	{		if (unencryptedString == null || unencryptedString.trim().length() == 0)			throw new IllegalArgumentException(					"unencrypted string was null or empty");		try 		{			SecretKey key = keyFactory.generateSecret(keySpec);			cipher.init(Cipher.ENCRYPT_MODE, key);			byte[] cleartext = unencryptedString.getBytes("UTF8");			byte[] ciphertext = cipher.doFinal(cleartext);			return Base64.encodeBytes(ciphertext);			// BASE64Encoder base64encoder = new BASE64Encoder();			// return base64encoder.encode( ciphertext );		} 		catch (Exception e)		{			throw new Exception(e);		}	}		public String decrypt(String encryptedString, int type) throws Exception	{		try		{			SecretKey key = keyFactory.generateSecret(keySpec);			cipher.init(Cipher.DECRYPT_MODE, key);			byte[] cleartext = Base64.decode(encryptedString);			byte[] ciphertext = cipher.doFinal(cleartext);			return bytes2String(ciphertext, type);		}		catch (Exception e)		{			if (e instanceof IOException) {				return encryptedString;			}else{				throw new Exception(e);			}					}	}	/**	 * 1，英文，2，中文	 * 	 * @param bytes	 * @param type	 * @return	 */	private static String bytes2String(byte[] bytes, int type)	{		if (type == 1) 		{			StringBuffer stringBuffer = new StringBuffer();			for (int i = 0; i < bytes.length; i++)			{				stringBuffer.append((char) bytes[i]);			}			String resultString = stringBuffer.toString();			return resultString;		} 		else if (type == 2)		{			try			{				return new String(bytes, "utf8");			} 			catch (UnsupportedEncodingException e)			{				e.printStackTrace();			}		}		return null;	}	public static String md5(String string)	{		byte[] hash;		try		{			hash = MessageDigest.getInstance("MD5").digest(string.getBytes("UTF-8"));		}		catch (NoSuchAlgorithmException e)		{			throw new RuntimeException("Huh, MD5 should be supported?", e);		}		catch (UnsupportedEncodingException e)		{			throw new RuntimeException("Huh, UTF-8 should be supported?", e);		}		StringBuilder hex = new StringBuilder(hash.length * 2);		for (byte b : hash)		{			if ((b & 0xFF) < 0x10)				hex.append("0");			hex.append(Integer.toHexString(b & 0xFF));		}		return hex.toString();	}}